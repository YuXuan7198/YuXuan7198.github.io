{"meta":{"title":"齐博文的博客","subtitle":"勤奋努力，知行合一","description":"电子科大在读研究生","author":"齐博文","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"1.Java基础之反射","slug":"1.Java基础之反射","date":"2019-10-23T09:06:43.163Z","updated":"2019-10-23T09:29:58.886Z","comments":true,"path":"2019/10/23/1.Java基础之反射/","link":"","permalink":"http://yoursite.com/2019/10/23/1.Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/","excerpt":"","text":"[toc] 反射机制反射的实现过程：Java语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下的几个部分。 类是用来描述一组对象，反射机制可以认为是用来描述一组类。 ​ Class： 用来描述类本身。 ​ Package： 用来描述类所属的包。 ​ Field： 用来描述类中的属性。 ​ Method： 用来描述类中的方法。 ​ Constructor： 用来描述类中的构造方法。 ​ Annotation： 用来描述类中的注解。 1.反射的作用​ 反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。在我们不了解这个类的时候，反射机制就很强大了。 2.如何获取class三种方式：123Class clazz = Class.forName(“包名.类名”);Class clazz = 类名.class;Class clazz = 对象.getClass(); 3.class中的常用方法（1）获取类的基本信息12int result = clazz.getModifiers();//获取类的修饰符(权限 特征)。 ==clazz.getModifiers()的返回值的含义如下：== 12345678910111213String name = clazz.getName();获取类的名字。String sname = clazz.getSimpleName();获取类的简单名字。Package p = clazz.getPackage();p.getName();获取包的名字：Class sclass = clazz.getSuperclass();获取当前clazz的父类。Class[] classes = clazz.getInterfaces();获取当前clazz的所有父类接口。Person p = (Person)clazz.newInstance();通过类创建对象。相当于调用了Person类中的默认无参构造方法创建对象。 （2）获取类中属性的方法123456789Filed[] fs = clazz.getField();获取类中的所有的属性，只能获取类的公有属性，并且可以获取继承过来的属性。 Field nameField = clazz.getField(“属性名”);根据类中某一属性的名称获取类的属性。且只能获取类的共有属性Field f = clazz.getDeclaredField(name);根据私有属性名获取该私有属性。并且该私有属性可设置为可操纵的。f.setAccessible(true);私有属性可以直接被操作。f.set(对象,”赋值”) (3) 获取类中函数的方法123456789101112Filed[] fs = clazz.getDeclaredFields();获取类中的所有的属性，能获取类的私有属性，但不可以获取继承过来的属性。Method m = clazz.getMethod(“方法名”，参数类型);获取类中的方法。可获取自己和父类的公有方法。Method[] ms = clazz.getMethods()；获取所有的公有方法（包括父类）。Method m = clazz.getDecleardMethod(“方法名”，参数类型);获取私有的方法Method ms = clazz.getDecleardMethods();获取所有的私有方法。同样使私有方法能操作可以使用ms.setAccessible(true);使私有函数可操作 （4）获取类中构造函数的方法12345Constructor&lt;Person&gt; con = clazz.getConstructor();Constructor[] cons = clazz.getConstructorsConstructor&lt;Person&gt; con = clazz.getDeclaredConstructor();Constructor[] cons = clazz.getDeclaredConstructors();con.setAccessible(true); 4.Filed中的常用方法12345678910（1）int m = field.getModifiers();获取属性的修饰符（2）Class fc = field.getType();获取属性的类型。（3）String name=field.getName();获取属性的名称。（4）field.set(对象,”赋值”)；给对象中的nameField属性赋值。相当于对象.nameField=赋值；对象可以通过Person p =(Person)clazz.newInstance();的方法来得到。（5）field.get(对象)；取出对象中nameField属性的值。 5. 使用反射机制修改类中私有属性的值（String） 6.Method中的常用方法（1）获取方法的基本属性 （2）如何操作方法 7.如何操作构造方法（主要针对有参）（1）获取构造方法的基本属性 （2）如何操作构造方法 8.反射的作用（1）什么是IOC和DI?IOC：对象的控制权反转，交给容器来完成。 DI：对象的控制权在容器手中，容器在创建对象的时候同时帮我们自动注入属性值。 IOC(Inversion of Control)叫控制反转，DI（Dependency Injection）叫依赖注入，是对IOC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。 一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。 （2）反射的小案例","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-23T02:15:36.490Z","updated":"2019-10-23T02:15:36.490Z","comments":true,"path":"2019/10/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}